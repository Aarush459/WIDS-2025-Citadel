# -*- coding: utf-8 -*-
"""run_simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lwq2X8VhlILgso-jT_Yeo5vjL861b8cw
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import heapq
from collections import deque, defaultdict
import itertools

from collections import deque, defaultdict
import itertools
import heapq

# ---------------- ORDER ----------------

class Order:
    def __init__(self, order_id, side, price, qty, timestamp):
        self.order_id = order_id
        self.side = side
        self.price = price
        self.qty = qty
        self.timestamp = timestamp

    def __repr__(self):
        return f"Order(id={self.order_id}, side={self.side}, price={self.price}, qty={self.qty})"


# ---------------- ORDER BOOK ----------------

class OrderBook:
    def __init__(self):
        # price -> FIFO queue
        self.bids = defaultdict(deque)
        self.asks = defaultdict(deque)

        # heaps for best-price lookup
        self.bid_heap = []   # max-heap via negative prices
        self.ask_heap = []   # min-heap

        self.order_id_counter = itertools.count(1)
        self.timestamp = 0

        # structured trade tape
        self.trades = []

    # ---------- BEST PRICES ----------

    def best_bid(self):
        while self.bid_heap:
            price = -self.bid_heap[0]
            if price in self.bids and self.bids[price]:
                return price
            heapq.heappop(self.bid_heap)
        return None

    def best_ask(self):
        while self.ask_heap:
            price = self.ask_heap[0]
            if price in self.asks and self.asks[price]:
                return price
            heapq.heappop(self.ask_heap)
        return None

    # ---------- LIMIT ORDERS ----------

    def add_limit_order(self, side, price, qty):
        self.timestamp += 1
        order_id = next(self.order_id_counter)
        incoming = Order(order_id, side, price, qty, self.timestamp)

        if side == "buy":
            self._match_buy(incoming)
            if incoming.qty > 0:
                if price not in self.bids:
                    heapq.heappush(self.bid_heap, -price)
                self.bids[price].append(incoming)

        elif side == "sell":
            self._match_sell(incoming)
            if incoming.qty > 0:
                if price not in self.asks:
                    heapq.heappush(self.ask_heap, price)
                self.asks[price].append(incoming)

        else:
            raise ValueError("Side must be 'buy' or 'sell'")

        return incoming

    # ---------- MARKET ORDERS ----------

    def add_market_order(self, side, qty):
        self.timestamp += 1
        order_id = next(self.order_id_counter)
        market_order = Order(order_id, side, None, qty, self.timestamp)

        if side == "buy":
            while market_order.qty > 0:
                best_ask = self.best_ask()
                if best_ask is None:
                    break

                resting = self.asks[best_ask][0]
                trade_qty = min(market_order.qty, resting.qty)

                market_order.qty -= trade_qty
                resting.qty -= trade_qty

                self.trades.append({
                    "time": self.timestamp,
                    "side": "BUY",
                    "price": best_ask,
                    "qty": trade_qty
                })

                if resting.qty == 0:
                    self.asks[best_ask].popleft()
                    if not self.asks[best_ask]:
                        del self.asks[best_ask]

        elif side == "sell":
            while market_order.qty > 0:
                best_bid = self.best_bid()
                if best_bid is None:
                    break

                resting = self.bids[best_bid][0]
                trade_qty = min(market_order.qty, resting.qty)

                market_order.qty -= trade_qty
                resting.qty -= trade_qty

                self.trades.append({
                    "time": self.timestamp,
                    "side": "SELL",
                    "price": best_bid,
                    "qty": trade_qty
                })

                if resting.qty == 0:
                    self.bids[best_bid].popleft()
                    if not self.bids[best_bid]:
                        del self.bids[best_bid]

        else:
            raise ValueError("Side must be 'buy' or 'sell'")

    # ---------- MATCHING HELPERS ----------

    def _match_buy(self, buy_order):
        while buy_order.qty > 0:
            best_ask = self.best_ask()
            if best_ask is None or best_ask > buy_order.price:
                break

            resting = self.asks[best_ask][0]
            trade_qty = min(buy_order.qty, resting.qty)

            buy_order.qty -= trade_qty
            resting.qty -= trade_qty

            self.trades.append({
                "time": self.timestamp,
                "side": "BUY",
                "price": best_ask,
                "qty": trade_qty
            })

            if resting.qty == 0:
                self.asks[best_ask].popleft()
                if not self.asks[best_ask]:
                    del self.asks[best_ask]

    def _match_sell(self, sell_order):
        while sell_order.qty > 0:
            best_bid = self.best_bid()
            if best_bid is None or best_bid < sell_order.price:
                break

            resting = self.bids[best_bid][0]
            trade_qty = min(sell_order.qty, resting.qty)

            sell_order.qty -= trade_qty
            resting.qty -= trade_qty

            self.trades.append({
                "time": self.timestamp,
                "side": "SELL",
                "price": best_bid,
                "qty": trade_qty
            })

            if resting.qty == 0:
                self.bids[best_bid].popleft()
                if not self.bids[best_bid]:
                    del self.bids[best_bid]

    # ---------- DEPTH VIEW ----------

    def print_top_levels(self, levels=5):
        print("\n--- ORDER BOOK ---")

        print("ASKS:")
        for price in sorted(self.asks.keys())[:levels]:
            print(f"{price} -> {sum(o.qty for o in self.asks[price])}")

        print("BIDS:")
        for price in sorted(self.bids.keys(), reverse=True)[:levels]:
            print(f"{price} -> {sum(o.qty for o in self.bids[price])}")

import heapq

class Event:
    def __init__(self, time, event_type, data):
        self.time = time
        self.event_type = event_type
        self.data = data

    def __lt__(self, other):
        return self.time < other.time

class SimulationEngine:
    def __init__(self, order_book):
        self.order_book = order_book
        self.event_queue = []
        self.current_time = 0

        # analytics storage
        self.snapshots = []

    def schedule_event(self, event):
        heapq.heappush(self.event_queue, event)

    def run(self):
        while self.event_queue:
            event = heapq.heappop(self.event_queue)
            self.current_time = event.time
            self.process_event(event)

    def process_event(self, event):
        if event.event_type == "limit":
            side, price, qty = event.data
            self.order_book.add_limit_order(side, price, qty)

        elif event.event_type == "market":
            side, qty = event.data
            self.order_book.add_market_order(side, qty)

        elif event.event_type == "snapshot":
            self.take_snapshot()

    def take_snapshot(self):
        best_bid = self.order_book.best_bid()
        best_ask = self.order_book.best_ask()

        if best_bid is not None and best_ask is not None:
            mid = (best_bid + best_ask) / 2
            spread = best_ask - best_bid
        else:
            mid = None
            spread = None

        self.snapshots.append({
            "time": self.current_time,
            "best_bid": best_bid,
            "best_ask": best_ask,
            "mid_price": mid,
            "spread": spread
        })

class TradeTape:
    def __init__(self, trades):
        self.trades = trades

    def vwap(self):
        total_qty = sum(t["qty"] for t in self.trades)
        if total_qty == 0:
            return None
        return sum(t["price"] * t["qty"] for t in self.trades) / total_qty

    def prices(self):
        return [t["price"] for t in self.trades]

import numpy as np

def extract_series(snapshots):
    times = []
    spreads = []
    mids = []

    for s in snapshots:
        if s["mid_price"] is not None:
            times.append(s["time"])
            spreads.append(s["spread"])
            mids.append(s["mid_price"])

    return times, spreads, mids

def mid_price_volatility(mids):
    if len(mids) < 2:
        return 0.0
    returns = np.diff(mids)
    return np.std(returns)

ob = OrderBook()
engine = SimulationEngine(ob)

# schedule events
engine.schedule_event(Event(1, "limit", ("sell", 101, 10)))
engine.schedule_event(Event(2, "limit", ("sell", 102, 10)))
engine.schedule_event(Event(3, "limit", ("buy", 100, 15)))
engine.schedule_event(Event(4, "market", ("buy", 12)))
engine.schedule_event(Event(7, "market", ("sell", 3)))
engine.schedule_event(Event(9, "market", ("buy", 4)))
engine.schedule_event(Event(11, "market", ("sell", 2)))
engine.schedule_event(Event(15, "limit", ("buy", 101, 5)))
engine.schedule_event(Event(16, "market", ("buy", 10)))
for t in range(5, 15):
    engine.schedule_event(Event(t, "snapshot", None))

# run simulation
engine.run()

# results
ob.print_top_levels()
print("Trades:", ob.trades)
print("Snapshots:")
for s in engine.snapshots:
    print(s)
# Trade analytics
tape = TradeTape(ob.trades)
print("VWAP:", tape.vwap())

# Snapshot analytics
times, spreads, mids = extract_series(engine.snapshots)

print("Spreads:", spreads)
print("Mid prices:", mids)

def make_ohlc_from_snapshots(snapshots, window=2):
    df = pd.DataFrame(snapshots)
    df = df.dropna(subset=["mid_price"])

    df["bucket"] = (df["time"] // window) * window

    ohlc = (
        df.groupby("bucket")["mid_price"]
          .agg(open="first", high="max", low="min", close="last")
          .reset_index()
    )
    return ohlc

ohlc = make_ohlc_from_snapshots(engine.snapshots, window=2)
ohlc

def plot_candles(ohlc):
    plt.figure(figsize=(10,4))
    for _, row in ohlc.iterrows():
        color = "green" if row["close"] >= row["open"] else "red"
        # wick
        plt.plot([row["bucket"], row["bucket"]], [row["low"], row["high"]])
        # body
        plt.plot([row["bucket"], row["bucket"]], [row["open"], row["close"]], linewidth=6)
    plt.title("Candlestick Chart (Mid-Price)")
    plt.xlabel("Time")
    plt.ylabel("Price")
    plt.show()

plot_candles(ohlc)

times, spreads, mids = extract_series(engine.snapshots)

plt.figure(figsize=(10,4))
plt.plot(times, spreads)
plt.title("Bid-Ask Spread Over Time")
plt.xlabel("Time")
plt.ylabel("Spread")
plt.show()

def rolling_volatility(mids, window=2):
    if len(mids) < window:
        return []
    return pd.Series(mids).diff().rolling(window).std()

vol = rolling_volatility(mids, window=2)

plt.figure(figsize=(10,4))
plt.plot(vol)
plt.title("Mid-Price Volatility (Rolling)")
plt.xlabel("Index")
plt.ylabel("Volatility")
plt.show()

from matplotlib.backends.backend_pdf import PdfPages

with PdfPages("simulation_report.pdf") as pdf:

    # Candlestick
    plt.figure(figsize=(10,4))
    for _, row in ohlc.iterrows():
        plt.plot([row["bucket"], row["bucket"]], [row["low"], row["high"]])
        plt.plot([row["bucket"], row["bucket"]], [row["open"], row["close"]], linewidth=6)
    plt.title("Candlestick Chart (Mid-Price)")
    plt.xlabel("Time")
    plt.ylabel("Price")
    pdf.savefig()
    plt.close()

    # Spread
    plt.figure(figsize=(10,4))
    plt.plot(times, spreads)
    plt.title("Bid-Ask Spread Over Time")
    plt.xlabel("Time")
    plt.ylabel("Spread")
    pdf.savefig()
    plt.close()

    # Volatility
    plt.figure(figsize=(10,4))
    plt.plot(vol)
    plt.title("Mid-Price Volatility (Rolling)")
    plt.xlabel("Index")
    plt.ylabel("Volatility")
    pdf.savefig()
    plt.close()